import json
from pathlib import Path
from typing import List, Dict, Optional

LOCATORS_PATH = Path(__file__).resolve().parents[1] / "locators" / "locators_db.json"

class LocatorStore:
    """
    Simple loader + manager for locator candidates.
    Keeps data in a JSON file. Loads once (cached) and allows reading/updating.
    """

    def __init__(self, path: Optional[Path] = None):
        self.path = Path(path) if path else LOCATORS_PATH
        self._data: Dict[str, Dict] = {}
        self._load()

    def _load(self):
        if not self.path.exists():
            # start with empty structure
            self._data = {}
            return
        with self.path.open("r", encoding="utf-8") as f:
            self._data = json.load(f)

    def save(self):
        """Persist current data back to the JSON file (safe overwrite)."""
        self.path.parent.mkdir(parents=True, exist_ok=True)
        with self.path.open("w", encoding="utf-8") as f:
            json.dump(self._data, f, indent=2, ensure_ascii=False)

    def get_candidates(self, key: str) -> List[str]:
        """
        Return ordered locator candidates for the given element key.
        First item is primary (if present), following are backups.
        """
        entry = self._data.get(key, {})
        candidates = []
        primary = entry.get("primary")
        if primary:
            candidates.append(primary)
        backups = entry.get("backups", [])
        candidates.extend([b for b in backups if b and b not in candidates])
        return candidates

    def add_or_update(self, key: str, primary: Optional[str] = None, backups: Optional[List[str]] = None, meta: Optional[Dict] = None):
        """
        Add a new element entry or update an existing one (in memory).
        Call save() to persist.
        """
        entry = self._data.get(key, {})
        if primary:
            entry["primary"] = primary
        if backups:
            entry["backups"] = backups
        if meta:
            entry["meta"] = meta
        self._data[key] = entry

    def register_healed_locator(self, key: str, healed_locator: str, promote: bool = True):
        """
        Called when a healed locator is found at runtime.
        By default it inserts the healed locator at the front of backups (or replaces primary if promote=True).
        Call save() to persist.
        """
        if key not in self._data:
            self._data[key] = {"primary": healed_locator, "backups": [], "meta": {}}
            return
        if promote:
            # make healed locator primary and push old primary to backups
            old_primary = self._data[key].get("primary")
            if old_primary and old_primary != healed_locator:
                backups = self._data[key].get("backups", [])
                backups.insert(0, old_primary)
                self._data[key]["backups"] = backups
            self._data[key]["primary"] = healed_locator
        else:
            backups = self._data[key].get("backups", [])
            if healed_locator not in backups:
                backups.insert(0, healed_locator)
            self._data[key]["backups"] = backups
